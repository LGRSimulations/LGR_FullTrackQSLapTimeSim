# Point mass lap sim - F25 (2024/25)
#------------------------Point Mass Lap Sim - 2024/25-------------------------#

# Load all necessary modules
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Insert file path to call UDFs
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../lib/UniversalUDFs')))
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../lib/Models')))

# UDFs
from track_data_processing import track_data # Function to process .txt file data
# Coordinates and the corresponding radii curvatures from input segment coordinates
from track_fit_segment import spline_track_fit
from track_fit_segment import curvature_and_radius
from track_fit_segment import distance_calc
from track_fit_segment import fit_circle

#------------------------------------------------------- TRACK DATA PROCESSING 

# Track layout - FSUK endurance event
# Call function to output x and y coordinate arrays for processed data with 
# an input file path
track_file = os.path.abspath(os.path.join(os.path.dirname(__file__), '../lib/Tracks/FSUK.txt'))
track_x_coordinates, track_y_coordinates = track_data(track_file)

#----------------------------------- TRACK MAP SPLINE FIT + RADIUS CALCULATION

# Conduct spline curve fit to track coordinates
num_points = 1000
x_fine, y_fine, num_points = spline_track_fit(track_x_coordinates, track_y_coordinates, num_points)

# Calculate curvature and radius throughout the fitted spline
curvature_values, radius_values = curvature_and_radius(x_fine, y_fine)

# Manually calculate radius between 3 subsequent coordinates
# Initiliase arrays - provided an initial radius value - inf
manual_radii = [1e4]
element_counter = [0]

for i in range(1, len(x_fine)-1):
    element_counter.append(i)
    
    radius, xc, yc = fit_circle(x_fine[i-1], x_fine[i], x_fine[i+1], y_fine[i-1], y_fine[i], y_fine[i+1])
    
    manual_radii.append(radius)
    
# Add final elements manually
element_counter.append(len(x_fine))
manual_radii.append(1e4)

# Print the element number, coordiantes, distances and manual vs analytically
# calculated raddi corresponding to each element.
# Initialise distance array
element_distance = [0]
cum_distance = [0]

for i in range(0, len(x_fine)):
  
    # Skip index 0
    if i == 0:
        continue
    
    else: # Add distance to array
        element_length = distance_calc(x_fine[i], x_fine[i-1], y_fine[i], y_fine[i-1])
        element_distance.append(element_length)
        # Add to cumulative distance
        cum_distance.append(element_length + cum_distance[i-1])
        
    # Print check that analytical and manual calculations are consistent
        
    # print(element_counter[i], round(x_fine[i], 1), round(y_fine[i], 1), '\t', 
    #       round(element_distance[i], 2), '\t', round(radius_values[i], 1),  '\t', 
    #       (manual_radii[i]), '\t')

# Plot track and curvature
plt.figure(figsize=(16, 9))
plt.scatter(x_fine, y_fine, c=radius_values, cmap='cool', label='Radius of Curvature (m)')
plt.plot(x_fine, y_fine, label='Track (Spline Fit)')
# plt.colorbar(label='Radius of Curvature (meters)')
plt.legend()
plt.title('Track Map')
plt.xlabel('X')
plt.ylabel('Y')
plt.grid()
plt.show()

#---------------------------------------------------- MAX VELOCITY CALCULATION  
# The first, fundamental velocity calculation 
# Calculate the maximum theoretical cornering velocity as a function of maximum
# lateral load generated by the tyre, mass, corner radius and aero drag

# Complete the initial sweep to determine max theoretical speed for given radii
from modes import max_corner_velocity

# Initialise v_max
v_max = [0]

# Loop through all elements and calculate their max cornering speeds.
for i in range(1,len(element_counter)):
    # Append to v_max array
    v_max.append(max_corner_velocity(manual_radii[i]))
    
# # Plot vmax vs distance
# plt.figure(figsize=(16, 9))
# plt.plot(cum_distance, v_max)
# plt.title('V_max')
# plt.xlabel('Distance (m)')
# plt.ylabel('V')
# plt.grid()
# plt.show()
    
#------------------------------------------ POWER-LIMITED VELOCITY CALCULATION
# Second mode: calculates maximum velocity through an element limited by the
# potential for power generation by the PU at any time.

# Import requried function
from PU_model import IC_PU_output # IC PU model
from PU_model import EV_PU_output # EV PU model
from modes import straight_exit_speed 
from PU_model import IC_stitch_bhp_wheel_speed # IC drivetrain model
 
# -------------------------------------------------------------- IC DEVELOPMENT
# # Retreieve IC PU & drivetrain data
# wheel_speeds_fitted_1, wheel_speeds_fitted_2, wheel_speeds_fitted_3, wheel_speeds_fitted_4, wheel_speeds_fitted_5, wheel_speeds_fitted_6, bhp_fitted = IC_PU_output()

# unique_wheel_speeds, max_bhp_values = IC_stitch_bhp_wheel_speed(wheel_speeds_fitted_1, wheel_speeds_fitted_2, wheel_speeds_fitted_3, 
#                            wheel_speeds_fitted_4, wheel_speeds_fitted_5, wheel_speeds_fitted_6, 
#                            bhp_fitted)
# ------------------------------------------------------------- IC DEVELOPMENT^

# Initialise v_power (power-limited velocities)
v_power = [0]

# Loop through all elements.
for i in range(1,len(element_counter)):
    if i == 1:
        u = 0.1 # Assign initial velocity slightly greater than 0

else: # Call on power-limited velocity calculation
    u = v_power[i-1] # Set initial velocity equal to the previous segment final velocity
    # v = straight_exit_speed(entry_speed, sector_length, available_engine_power)
    
    # Append to v_max array
    # v_power.append(v)
    
# # Plot vmax vs distance
# plt.figure(figsize=(16, 9))
# plt.plot(cum_distance, v_max)
# plt.title('V_max')
# plt.xlabel('Distance (m)')
# plt.ylabel('V')
# plt.grid()
# plt.show()



